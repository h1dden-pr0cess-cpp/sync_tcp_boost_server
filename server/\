#include "Session.hpp"

Session::Session(int id, boost::asio::ip::tcp::socket socket)
    : id_(id),
      socket_(std::move(socket))
{}

int Session::id() const {
    return id_;
}

void Session::start() {
    read_header();
}


static std::string read_string(const std::vector<uint8_t>& buf, size_t& offset)
{
    if (offset + sizeof(uint16_t) > buf.size())
        throw std::runtime_error("Bad packet (string length)");

    uint16_t len;
    std::memcpy(&len, &buf[offset], sizeof(len));
    offset += sizeof(len);

    if (offset + len > buf.size())
        throw std::runtime_error("Bad packet (string data)");

    std::string s(reinterpret_cast<const char*>(&buf[offset]), len);
    offset += len;

    return s;
}

void Session::read_header() {
    auto self = shared_from_this();

    boost::asio::async_read(
        socket_,
        boost::asio::buffer(&packet_type_, sizeof(packet_type_)),
        [self](boost::system::error_code ec, std::size_t) {
            if (ec) {
				self->socket_.close();
				return;
			}

            boost::asio::async_read(
                self->socket_,
                boost::asio::buffer(&self->packet_size_, sizeof(self->packet_size_)),
                [self](boost::system::error_code ec, std::size_t) {
                    if (ec) {
						self->socket_.close();
						return;
					}

                    self->body_.resize(self->packet_size_);
                    self->read_body();
                }
            );
        }
    );
}


void Session::read_body() {
    auto self = shared_from_this();

    if (packet_size_ == 0) {
        handle_packet();
        read_header();
        return;
    }

    boost::asio::async_read(
        socket_,
		boost::asio::buffer(body_),
		[self](boost::system::error_code ec, std::size_t) {
            if (ec) {
			self->socket_.close();
			return;
		}


            self->handle_packet();
            self->read_header();
        }
    );
}


void Session::handle_packet() {
    PacketType type = static_cast<PacketType>(packet_type_);

    // üîí –µ—Å–ª–∏ –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω ‚Äî —Ä–∞–∑—Ä–µ—à–∞–µ–º —Ç–æ–ª—å–∫–æ –ª–æ–≥–∏–Ω/—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é
    if (!authorized_ &&
        type != PacketType::RegisterUser &&
        type != PacketType::LoginWithPassword &&
        type != PacketType::LoginWithToken)
    {
        std::cout << "Client " << id_ << " not authorized\n";
        return;
    }

    switch(type) {
        case PacketType::Ping:
            Packet response;
			response.type = PacketType::Ping; // echo
			send_packet(response);
			break;

        case PacketType::RegisterUser:
            handle_register(body_);
            break;

        case PacketType::LoginWithPassword:
            handle_login_password(body_);
            break;

        case PacketType::LoginWithToken:
            handle_login_token(body_);
            break;

        case PacketType::Logout:
            authorized_ = false;
            username_.clear();
            std::cout << "Client " << id_ << " logged out\n";
            break;

        case PacketType::UploadChunk:
            std::cout << "Upload chunk from user " << username_ << "\n";
            break;

        case PacketType::Download:
            std::cout << "Download request from user " << username_ << "\n";
            break;

        case PacketType::ListFiles:
            std::cout << "List files request from user " << username_ << "\n";
            break;

        default:
            std::cout << "Unknown packet from client " << id_ << "\n";
            break;
    }
}

void Session::handle_register(const std::vector<uint8_t>& body)
{
    try {
        size_t offset = 0;

        std::string username = read_string(body, offset);
        std::string password_hash = read_string(body, offset);

        std::cout << "Register: user=" << username << "\n";

        // TODO: —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    }
    catch (const std::exception& e) {
        std::cout << "Bad Register packet: " << e.what() << "\n";
    }
}


void Session::handle_login_password(const std::vector<uint8_t>& body)
{
    try {
        size_t offset = 0;

        std::string username = read_string(body, offset);
        std::string password_hash = read_string(body, offset);

        std::cout << "LoginWithPassword: user=" << username << "\n";

        // üîê –ø–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –ø—Ä–∏–Ω–∏–º–∞–µ–º
        authorized_ = true;
        username_ = username;
    }
    catch (const std::exception& e) {
        std::cout << "Bad LoginWithPassword packet: " << e.what() << "\n";
    }
}


void Session::handle_login_token(const std::vector<uint8_t>& body)
{
    try {
        size_t offset = 0;

        std::string token = read_string(body, offset);

        std::cout << "LoginWithToken: token=" << token << "\n";

        // TODO: –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–æ–∫–µ–Ω
        authorized_ = true;
        username_ = "user_from_token";
    }
    catch (const std::exception& e) {
        std::cout << "Bad LoginWithToken packet: " << e.what() << "\n";
    }
}

void Session::send_packet(const Packet& packet)
{
	uint32_t size = static_cast<uint32_t>(packet.body.size());

    auto buffer = std::make_shared<std::vector<uint8_t>>(1 + 4 + size);

    (*buffer)[0] = static_cast<uint8_t>(packet.type);
    std::memcpy(buffer->data() + 1, &size, sizeof(size));

    if (size > 0)
        std::memcpy(buffer->data() + 5, packet.body.data(), size);

    auto self = shared_from_this();

    boost::asio::async_write(
        socket_,
        boost::asio::buffer(*buffer),
        [self, buffer](boost::system::error_code ec, std::size_t)
        {
            if (ec)
                self->socket_.close();
        }
    );
}

